<!DOCTYPE HTML>
<html ng-app="companyname">
  <head>
    <meta charset="utf-8">
	<meta name="keywords" content="Companyname" />
	<meta name="description" content="We are here to create your online presense and style" />
	<meta property="og:title" content="Companyname is a company from Russia." />
    <meta property="og:url" content="#" />
    <meta property="og:site_name" content="Companyname"/>
    <meta property="og:description" content="We are here to create your online presense and style"/>
    <meta property="og:image" content="" />
    <link rel="preload" href="/css/style.css" as="style" onload="this.rel='stylesheet'">
	  <link rel="stylesheet" type="text/css" href="css/style.css">
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>First maket</title>

    <script>
			function loadFont(a, b, c) {
				function d() {
					if (!window.FontFace) return !1;
					var a = new FontFace("t", 'url("data:font-woff2,") format("woff2")');
					return a.load(), "loading" === a.status
				}
				var e = navigator.userAgent,
				f = !window.addEventListener || e.match(/(Android (2|3|4.0|4.1|4.2|4.3))|(Opera (Mini|Mobi))/) && !e.match(/Chrome/);
				if (!f) {
					var g = {};
					try {
						g = localStorage || {}
					} catch (h) {}
					var i = "x-font-" + a,
					j = i + "url",
					k = i + "css",
					l = g[j],
					m = g[k],
					n = document.createElement("style");
					if (n.rel = "stylesheet", document.head.appendChild(n), !m || l !== b && l !== c) {
						var o = c && d() ? c : b,
						p = new XMLHttpRequest;
						p.open("GET", o), p.onload = function() {
							p.status >= 200 && p.status < 400 && (g[j] = o, g[k] = n.textContent = p.responseText)
						}, p.send()
					} else n.textContent = m
				}
			}
		</script>
		<script>
			loadFont('Cabin Regular','/css/fonts.woff.css', '/css/fonts.woff2.css')
		</script>
    <script>
		/*! loadCSS: load a CSS file asynchronously. [c]2016 @scottjehl, Filament Group, Inc. Licensed MIT */
		(function(w){
			"use strict";
			/* exported loadCSS */
			var loadCSS = function( href, before, media ){
			var doc = w.document;
				var ss = doc.createElement( "link" );
				var ref;
				if( before ){
					ref = before;
				}
				else {
					var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
					ref = refs[ refs.length - 1];
				}

				var sheets = doc.styleSheets;
				ss.rel = "stylesheet";
				ss.href = href;
				// temporarily set media to something inapplicable to ensure it'll fetch without blocking render
				ss.media = "only x";

				// wait until body is defined before injecting link. This ensures a non-blocking load in IE11.
				function ready( cb ){
					if( doc.body ){
						return cb();
					}
					setTimeout(function(){
						ready( cb );
					});
				}
				// Inject link
					// Note: the ternary preserves the existing behavior of "before" argument, but we could choose to change the argument to "after" in a later release and standardize on ref.nextSibling for all refs
					// Note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/
				ready( function(){
					ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
				});
				// A method (exposed on return object for external use) that mimics onload by polling until document.styleSheets until it includes the new sheet.
				var onloadcssdefined = function( cb ){
					var resolvedHref = ss.href;
					var i = sheets.length;
					while( i-- ){
						if( sheets[ i ].href === resolvedHref ){
							return cb();
						}
					}
					setTimeout(function() {
						onloadcssdefined( cb );
					});
				};

				function loadCB(){
					if( ss.addEventListener ){
						ss.removeEventListener( "load", loadCB );
					}
					ss.media = media || "all";
				}

				// once loaded, set link's media back to `all` so that the stylesheet applies once it loads
				if( ss.addEventListener ){
					ss.addEventListener( "load", loadCB);
				}
				ss.onloadcssdefined = onloadcssdefined;
				onloadcssdefined( loadCB );
				return ss;
			};
			// commonjs
			if( typeof exports !== "undefined" ){
				exports.loadCSS = loadCSS;
			}
			else {
				w.loadCSS = loadCSS;
			}
		}( typeof global !== "undefined" ? global : this ));

		/* CSS rel=preload polyfill (from src/cssrelpreload.js) */
		/* CSS rel=preload polyfill. Depends on loadCSS function */
		(function( w ){
		  // rel=preload support test
		  if( !w.loadCSS ){
		    return;
		  }
		  var rp = loadCSS.relpreload = {};
		  rp.support = function(){
		    try {
		      return w.document.createElement("link").relList.supports( "preload" );
		    } catch (e) {}
		  };

		  // loop preload links and fetch using loadCSS
		  rp.poly = function(){
		    var links = w.document.getElementsByTagName( "link" );
		    for( var i = 0; i < links.length; i++ ){
		      var link = links[ i ];
		      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" ){
		        w.loadCSS( link.href, link );
		        link.rel = null;
		      }
		    }
		  };

		  // if link[rel=preload] is not supported, we must fetch the CSS manually using loadCSS
		  if( !rp.support() ){
		    rp.poly();
		    var run = w.setInterval( rp.poly, 300 );
		    if( w.addEventListener ){
		      w.addEventListener( "load", function(){
		        w.clearInterval( run );
		      } )
		    }
		  }
		}( this ));

		</script>

  </head>
  <body>
	
	<ng-view> </ng-view>
  
	<script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
	<!-- <script src="//cdnjs.cloudflare.com/ajax/libs/handlebars.js/2.0.0/handlebars.min.js"></script>
	<script src="script.js"></script> -->

  <script src="angular.min.js"></script>
  <script src="angular-route.js"></script>
  <script src="ang.js"></script>
  </body>
</html>
